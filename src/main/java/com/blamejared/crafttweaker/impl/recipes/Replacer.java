package com.blamejared.crafttweaker.impl.recipes;

import com.blamejared.crafttweaker.CraftTweaker;
import com.blamejared.crafttweaker.api.CraftTweakerAPI;
import com.blamejared.crafttweaker.api.annotations.ZenRegister;
import com.blamejared.crafttweaker.api.item.IIngredient;
import com.blamejared.crafttweaker.api.item.IItemStack;
import com.blamejared.crafttweaker.api.managers.IRecipeManager;
import com.blamejared.crafttweaker.api.recipes.IReplacementRule;
import com.blamejared.crafttweaker.api.zencode.impl.util.PositionUtil;
import com.blamejared.crafttweaker.impl.brackets.RecipeTypeBracketHandler;
import com.blamejared.crafttweaker.impl.recipes.replacement.FullIngredientReplacementRule;
import com.blamejared.crafttweaker.impl.recipes.replacement.IngredientReplacementRule;
import com.blamejared.crafttweaker.impl.recipes.replacement.ReplacerAction;
import com.blamejared.crafttweaker.impl.recipes.replacement.StackTargetingReplacementRule;
import com.blamejared.crafttweaker.impl.recipes.wrappers.WrapperRecipe;
import com.blamejared.crafttweaker.impl.util.NameUtils;
import com.blamejared.crafttweaker_annotations.annotations.Document;
import net.minecraft.item.crafting.IRecipe;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.common.util.Lazy;
import org.openzen.zencode.java.ZenCodeType;
import org.openzen.zencode.shared.CodePosition;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.TreeMap;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;

@ZenRegister
@ZenCodeType.Name("crafttweaker.api.recipes.Replacer")
@Document("vanilla/api/recipes/Replacer")
public final class Replacer {
    private static final Supplier<Function<ResourceLocation, ResourceLocation>> DEFAULT_REPLACER = Lazy.concurrentOf(
            () -> id -> CraftTweaker.MODID.equals(id.getNamespace()) && id.getPath().startsWith("autogenerated.")? id :
                    new ResourceLocation(CraftTweaker.MODID, "autogenerated." + id.getNamespace() + "." + id.getPath())
    );
    private static final Supplier<BiFunction<ResourceLocation, Function<ResourceLocation, String>, String>> DEFAULT_CUSTOM_FUNCTION = Lazy.concurrentOf(
            () -> (id, defaultFunction) -> defaultFunction.apply(id)
    );
    
    private final Collection<IRecipeManager> targetedManagers;
    private final Collection<? extends IRecipe<?>> targetedRecipes;
    private final List<IReplacementRule> rules;
    private final Map<ResourceLocation, String> userRenames;
    
    private BiFunction<ResourceLocation, Function<ResourceLocation, String>, String> userRenamingFunction;
    
    private Replacer(final Collection<? extends IRecipe<?>> recipes, final Collection<IRecipeManager> managers) {
        this.targetedManagers = Collections.unmodifiableCollection(managers);
        this.targetedRecipes = Collections.unmodifiableCollection(recipes);
        this.rules = new ArrayList<>();
        this.userRenames = new TreeMap<>();
        this.userRenamingFunction = null;
    }
    
    @ZenCodeType.Method
    public static Replacer forRecipes(final WrapperRecipe... recipes) {
        if (recipes.length <= 0) {
            throw new IllegalArgumentException("Unable to create a replacer without any targeted recipes");
        }
        return new Replacer(Arrays.stream(recipes).map(WrapperRecipe::getRecipe).collect(Collectors.toSet()), Collections.emptyList());
    }
    
    @ZenCodeType.Method
    public static Replacer forTypes(final IRecipeManager... managers) {
        if (managers.length <= 0) {
            throw new IllegalArgumentException("Unable to create a replacer without any targeted recipe types");
        }
        return new Replacer(Collections.emptyList(), new HashSet<>(Arrays.asList(managers)));
    }
    
    @ZenCodeType.Method
    public static Replacer forAllTypes() {
        return forAllTypesExcluding();
    }
    
    @ZenCodeType.Method
    public static Replacer forAllTypesExcluding(final IRecipeManager... managers) {
        final List<IRecipeManager> managerList = Arrays.asList(managers);
        return new Replacer(
                Collections.emptyList(),
                RecipeTypeBracketHandler.getManagerInstances().stream().filter(manager -> !managerList.contains(manager)).collect(Collectors.toSet())
        );
    }
    
    @ZenCodeType.Method
    public Replacer replace(final IIngredient from, final IIngredient to) {
        if (from instanceof IItemStack) return this.replaceStack((IItemStack) from, to);
        return this.addReplacementRule(IngredientReplacementRule.create(from, to));
    }
    
    @ZenCodeType.Method
    public Replacer replaceStack(final IItemStack from, final IIngredient to) {
        return this.addReplacementRule(StackTargetingReplacementRule.create(from, to));
    }
    
    @ZenCodeType.Method
    public Replacer replaceFully(final IIngredient from, final IIngredient to) {
        return this.addReplacementRule(FullIngredientReplacementRule.create(from, to));
    }
    
    @ZenCodeType.Method
    public Replacer explicitlyRename(final ResourceLocation oldName, final String newName) {
        final String actualNewName = this.fix(newName, oldName);
        if (this.userRenames.containsKey(oldName) && !this.userRenames.get(oldName).equals(actualNewName)) {
            CraftTweakerAPI.logError(
                    "The same old name '%s' has been specified twice for renaming with two different strings '%s' and '%s': only the former will apply",
                    oldName,
                    this.userRenames.get(oldName),
                    newName
            );
            return this;
        }
        
        this.userRenames.put(oldName, actualNewName);
        return this;
    }
    
    @ZenCodeType.Method
    public Replacer useForRenaming(final BiFunction<ResourceLocation, Function<ResourceLocation, String>, String> function) {
        if (this.userRenamingFunction != null) {
            final CodePosition position = PositionUtil.getZCScriptPositionFromStackTrace();
            CraftTweakerAPI.logWarning("%sA renaming function has already been specified for this replacer: the old one will be replaced", position == null? "" : position + ": ");
        }
        
        this.userRenamingFunction = function;
        return this;
    }
    
    @ZenCodeType.Method
    public void execute() {
        if (this.rules.isEmpty()) return;
        CraftTweakerAPI.apply(new ReplacerAction(this.targetedManagers, this.targetedRecipes, Collections.unmodifiableList(this.rules), this.buildGeneratorFunction()));
    }
    
    private Replacer addReplacementRule(final IReplacementRule rule) {
        if (rule == IReplacementRule.EMPTY) return this;
        this.rules.add(rule);
        return this;
    }
    
    private String fix(final String newName, final ResourceLocation oldName) {
        final CodePosition position = PositionUtil.getZCScriptPositionFromStackTrace();
        return NameUtils.fixing(
                newName,
                (fixed, mistakes) -> CraftTweakerAPI.logWarning(
                        "%sInvalid recipe rename '%s' from '%s', mistakes:\n%s\nThe new rename '%s' will be used",
                        position == null ? "" : position + ": ",
                        newName,
                        oldName,
                        String.join("\n", mistakes),
                        fixed
                )
        );
    }
    
    private Function<ResourceLocation, ResourceLocation> buildGeneratorFunction() {
        if (this.userRenames.isEmpty() && this.userRenamingFunction == null) return DEFAULT_REPLACER.get();

        final BiFunction<ResourceLocation, Function<ResourceLocation, String>, String> customFunction =
                Optional.ofNullable(this.userRenamingFunction).orElseGet(DEFAULT_CUSTOM_FUNCTION);
        
        final Function<String, ResourceLocation> fixer = replacement -> NameUtils.fromFixedName(
                replacement,
                (fixed, mistakes) -> CraftTweakerAPI.logWarning(
                        "Invalid recipe rename '%s' specified in custom renaming function, mistakes:\n%s\nThe new rename will be '%s'",
                        replacement,
                        String.join("\n", mistakes),
                        fixed
                )
        );
        
        return id -> fixer.apply(customFunction.apply(id, it -> Optional.ofNullable(this.userRenames.get(it)).orElseGet(() -> DEFAULT_REPLACER.get().apply(it).getPath())));
    }
}
